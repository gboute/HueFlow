<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HueFlow</title>
  <style>
    @font-face {
      font-family: 'KiwiSoda';
      src: url('KiwiSoda.woff2') format('woff2');
      font-weight: normal;
      font-style: normal;
    }

    body {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  font-family: 'KiwiSoda', sans-serif;
   }

    #landing, #game {
  text-align: center;
  font-family: 'KiwiSoda', sans-serif;
  font-size: 1.4rem;
    }

    #level-select {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin-top: 20px;
    }

    .level-btn {
  font-family: 'KiwiSoda', sans-serif;
      padding: 10px 20px;
      font-size: 1.4rem;
      cursor: pointer;
      background-color: #ccc;
      border: none;
      border-radius: 5px;
      transition: background-color 0.3s;
    }

    .level-btn:hover {
      background-color: #aaa;
    }

    .hidden {
      display: none;
    }

    #grid {
  display: grid;
  width: 240px;
  gap: 0;
  padding: 0;
  margin: 0 auto;
}

    .tile {
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #666;
      color: white;
      font-weight: bold;
      user-select: none;
      transition: transform 0.3s ease;
      box-sizing: border-box;
      margin: 0;
      border: none;
      font-size: 1.4rem;
    }

    .anchor {
      cursor: not-allowed !important;
    }

    #back {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 10px 15px;
      background-color: #888;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    #test-instruction {
      font-size: 1.2rem;
      color: #444;
    }
  </style>
</head>
<body>
<!-- (rest of document continues unchanged) -->
    <p id="test-instruction" class="hidden">Arrange the tiles in order from 1 to 16.</p>
  <div id="landing">
    <h1>Welcome to HueFlow</h1>
    <p>Immerse yourself in the soothing world of color gradients.</p>
    <p>Select a level to begin:</p>
    <div id="level-select">
      <button class="level-btn" data-level="1">Level 1</button>
      <button class="level-btn" data-level="2">Level 2</button>
      <button class="level-btn" data-level="3">Level 3</button>
      <button class="level-btn" data-level="4">Level 4</button>
      <button class="level-btn" data-level="5">Level 5</button>
      <button class="level-btn" data-level="test">Test Level</button>
    </div>
  </div>
  <div id="game" class="hidden">
    <button id="back">&larr; Back</button>
    <h2 id="level-title"></h2>
    <div id="grid"></div>
    <p id="message"></p>
  </div>
  <script>
    const levelButtons = document.querySelectorAll('.level-btn');
    const landing = document.getElementById('landing');
    const game = document.getElementById('game');
    const levelTitle = document.getElementById('level-title');
    const grid = document.getElementById('grid');
    const backBtn = document.getElementById('back');
    const message = document.getElementById('message');
    const instruction = document.getElementById('test-instruction');

    function generateGradient(size) {
      const anchors = {
        tl: [255, 0, 0],
        tr: [255, 255, 0],
        bl: [0, 0, 255],
        br: [255, 0, 255]
      };

      const gradient = [];

      for (let row = 0; row < size; row++) {
        const y = row / (size - 1);
        for (let col = 0; col < size; col++) {
          const x = col / (size - 1);

          const top = [
            (1 - x) * anchors.tl[0] + x * anchors.tr[0],
            (1 - x) * anchors.tl[1] + x * anchors.tr[1],
            (1 - x) * anchors.tl[2] + x * anchors.tr[2]
          ];
          const bottom = [
            (1 - x) * anchors.bl[0] + x * anchors.br[0],
            (1 - x) * anchors.bl[1] + x * anchors.br[1],
            (1 - x) * anchors.bl[2] + x * anchors.br[2]
          ];
          const rgb = [
            Math.round((1 - y) * top[0] + y * bottom[0]),
            Math.round((1 - y) * top[1] + y * bottom[1]),
            Math.round((1 - y) * top[2] + y * bottom[2])
          ];

          const color = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
          const index = row * size + col;
          gradient.push({ color, label: index + 1 });
        }
      }

      return gradient;
    }

    const levels = {
      1: generateGradient(4),
      2: generateGradient(5),
      3: generateGradient(6),
      4: generateGradient(7),
      5: generateGradient(8),
      test: generateGradient(4)
    };

    let solution = [];
    let currentTiles = [];
    let anchors = [];
    let selectedIndex = null;
    let currentLevel = null;

    function getAnchorIndices(size) {
      return [0, size - 1, size * (size - 1), size * size - 1];
    }

    function updateGridSize(size) {
      grid.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
      grid.style.gridTemplateRows = `repeat(${size}, 1fr)`;
      const tileSize = Math.floor(240 / size);
      const style = document.createElement('style');
      style.innerHTML = `.tile { width: ${tileSize}px; height: ${tileSize}px; }`;
      document.head.appendChild(style);
    }

    function shuffle(array) {
      let currentIndex = array.length, randomIndex;
      while (currentIndex !== 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
      }
      return array;
    }

    function shuffleWithAnchors(array) {
      let movable = array.filter((_, i) => !anchors.includes(i));
      let shuffled = shuffle([...movable]);
      return array.map((val, i) => anchors.includes(i) ? val : shuffled.shift());
    }

    function renderGrid(tiles) {
      grid.innerHTML = '';
      instruction.classList.toggle('hidden', currentLevel !== 'test');
      tiles.forEach((tileData, index) => {
        const tile = document.createElement('div');
        tile.className = 'tile';
        const color = tileData.color || tileData;
        tile.style.backgroundColor = color;

        if (anchors.includes(index)) {
          tile.classList.add('anchor');
          tile.textContent = 'âœ¿';
          tile.style.fontSize = '1.5rem';
        } else {
          tile.setAttribute('draggable', true);
          tile.addEventListener('click', () => handleTileClick(index));
          tile.addEventListener('dragstart', (e) => e.dataTransfer.setData('text/plain', index));
          tile.addEventListener('dragover', (e) => e.preventDefault());
          tile.addEventListener('drop', (e) => {
            e.preventDefault();
            const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
            handleTileSwap(fromIndex, index);
          });

          if (currentLevel === 'test') {
            tile.textContent = tileData.label;
            tile.style.color = 'white';
            tile.style.fontWeight = 'bold';
          }
        }

        grid.appendChild(tile);
      });
    }

    function handleTileClick(index) {
      if (selectedIndex === null) {
        selectedIndex = index;
        grid.children[index].style.outline = '2px solid black';
      } else {
        grid.children[selectedIndex].style.outline = '';
        handleTileSwap(selectedIndex, index);
        selectedIndex = null;
      }
    }

    function handleTileSwap(i, j) {
      if (!anchors.includes(i) && !anchors.includes(j)) {
        const tiles = Array.from(grid.children);
        const tileA = tiles[i];
        const tileB = tiles[j];
        const rectA = tileA.getBoundingClientRect();
        const rectB = tileB.getBoundingClientRect();
        const dx = rectB.left - rectA.left;
        const dy = rectB.top - rectA.top;
        tileA.style.transform = `translate(${dx}px, ${dy}px)`;
        tileB.style.transform = `translate(${-dx}px, ${-dy}px)`;
        tileA.style.zIndex = 1;
        tileB.style.zIndex = 1;
        setTimeout(() => {
          tileA.style.transition = 'none';
          tileB.style.transition = 'none';
          tileA.style.transform = '';
          tileB.style.transform = '';
          tileA.style.zIndex = '';
          tileB.style.zIndex = '';
          [currentTiles[i], currentTiles[j]] = [currentTiles[j], currentTiles[i]];
          renderGrid(currentTiles);
          checkWin();
        }, 300);
      }
    }

    function checkWin() {
      const won = currentTiles.every((val, i) => val.color === solution[i].color);
      message.textContent = won ? 'ðŸŽ‰ Puzzle Solved!' : '';
    }

    levelButtons.forEach(button => {
      button.addEventListener('click', () => {
        const level = button.dataset.level;
        currentLevel = level;
        landing.classList.add('hidden');
        game.classList.remove('hidden');
        levelTitle.textContent = `Level ${level}`;
        solution = [...levels[level]];
        const size = Math.sqrt(solution.length);
        anchors = getAnchorIndices(size);
        updateGridSize(size);
        currentTiles = shuffleWithAnchors(solution);
        renderGrid(currentTiles);
      });
    });

    backBtn.addEventListener('click', () => {
      game.classList.add('hidden');
      landing.classList.remove('hidden');
      grid.innerHTML = '';
      message.textContent = '';
      selectedIndex = null;
    });
  </script>
</body>
</html>